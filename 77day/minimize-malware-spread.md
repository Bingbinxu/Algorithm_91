**方法**
据提供的edge的关系，构建图中的若干连通分量
**代码**
```C++
实现语言: C++
class Solution {
    vector<int> Father, sz, pc; // pc (point count): 连通块中一共有多少个被感染的点   
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial)
    {
        const int n = graph.size();
        for (int i = 0; i < n; i++)
        {
            Father.push_back(i);
            sz.push_back(1);
            pc.push_back(0); // 一开始每个连通块都没有被感染的点
        }
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) /* 将所有连通的集合合并 */
                if (graph[i][j] && find(i) != find(j)) /* i, j之间有边, 但不在一个连通块内 */
                {
                    sz[find(i)] += sz[find(j)];
                    Father[find(j)] = find(i);
                }

        for (auto& x : initial)
            pc[find(x)]++;

        int rs = -1, rp = INT_MAX; // rs: 可以被拯救的点数, rp: 结点的编号
        for (auto& x : initial)
        {
            if (rs == -1)
                rp = min(rp, x); /* 如果没有选择过任意一个点的话, 可以随便选一个点 */
            if (pc[find(x)] == 1) // 当前连通块只包含1个被感染的点的话
            {
                if (rs < sz[find(x)])  // rs 不如当前的点好的话
                {
                    rs = sz[find(x)];
                    rp = x;
                }
                else if (rs == sz[find(x)])
                {
                    rp = min(rp, x); /* 取编号最小的一个点 */
                }
            }
        }
        return rp;
    }

    int find(int x)
    {
        if (Father[x] != x)
            Father[x] = find(Father[x]);
        return Father[x];
    }
};
```
**复杂度分析**
时间复杂度: O(N^2)
空间复杂度: O(N^2+M)
